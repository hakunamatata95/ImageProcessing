% Carica l'immagine MRI del polmone
img = imread('imagesProject\tumore1.png');

img = Helpers.rgb2gray(img);

% Ridimensionamento dell'immagine
preprocessedImg = Helpers.resize(img, 770);
preprocessedImg = wiener2(preprocessedImg);

% Miglioramento del contrasto
preprocessedImg = imadjust(preprocessedImg);


se = strel("diamond",5);
marker = imerode(preprocessedImg,se);
preprocessedImg = imreconstruct(marker ,preprocessedImg);
 
preprocessedImg = imgaussfilt(preprocessedImg, 3);
Helpers.imsshow({img, preprocessedImg}, {'Original Image', 'After preprocessingImage'});
% Applicazione dell'operatore Sobel per migliorare i gradienti lungo gli assi orizzontali e verticali
%sobel_x = [-1 0 1; -2 0 2; -1 0 1]; % Sobel kernel per Gx
%sobel_y = [-1 -2 -1; 0 0 0; 1 2 1]; % Sobel kernel per Gy

% Calcolo del gradiente con Sobel
[Gx, Gy] = imgradientxy(preprocessedImg, 'Sobel'); % Example: Sobel gradient
gradiente_magnitude = sqrt(Gx.^2 + Gy.^2);


% Marcatori interni - puoi modificarli per selezione manuale
internal_markers = imclose(img > 0.8, ones(3,3)); % Esempio di thresholding

% Distanza trasformata dei marcatori interni
distance_transform = bwdist(internal_markers);
 
% Marcatori esterni - sfruttando la distanza trasformata
external_markers = distance_transform == round(max(distance_transform(:))/2);

% Combina marcatori interni ed esterni
markers = internal_markers | external_markers;

% Unisci i marcatori interni ed esterni
marcatori = imimposemin(gradiente_magnitude, markers);

% Calcola la segmentazione watershed
segmentazione = watershed(marcatori)

% Post-processing (rimuovi piccoli oggetti opzionale)
% segmented_img = bwareaopen(segmented_img, 100);

% Colora il tumore (etichette assegnate in base ai marcatori)
colored_img = label2rgb(segmentazione);

% Visualizza l'immagine segmentata
imshow(colored_img)


% Applicazione della convoluzione dell'immagine con i kernel Sobel
%gradiente_x = imfilter(double(preprocessedImg), sobel_x);
%gradiente_y = imfilter(double(preprocessedImg), sobel_y);

% Calcolo del gradiente totale utilizzando la magnitudine del gradiente
%gradienteMagnitudine = sqrt(gradiente_x.^2 + gradiente_y.^2);

% Calcolo dell'angolo del gradiente
%gradiente_angolo = atan2(gradiente_y, gradiente_x);

% TODO: minimi o massimi nell'articolo. Trova i massimi locali nell'immagine del gradiente   
%internalMarkers  = imregionalmax(gradienteMagnitude, 6);

% Trova i marcatori esterni
distanceTransform  = bwdist(internalMarkers);


% Marcatori esterni - sfruttando la distanza trasformata
external_markers = distance_transform == round(max(distance_transform(:))/2);

externalMarkers = imregionalmin(distanceTransform);

Helpers.imsshow({img, label}, {'Immagine originale', 'Segmentazione Watershed'});

figure
imshow(img)
hold on
overlaySeg = imshow(label);
overlaySeg.AlphaData = 0.3;
title("Colored Labels Superimposed Transparently on Original Image")

% Calcola l'area del tumore utilizzando l'analisi dei componenti connessi
regioni = bwlabel(segmentazione);
tumore_area = max(histcounts(regioni, 'BinMethod', 'integers'));

% Visualizza l'area del tumore
disp(['L''area del tumore Ã¨: ', num2str(tumore_area), ' pixel']);
